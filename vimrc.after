" color
colorscheme Tomorrow-Night

"nerdtree
let g:NERDTreeHijackNetrw=1
let g:nerdtree_tabs_autoclose=0

" ctags
function! DelTagOfFile(file)
  let fullpath = a:file
  let cwd = getcwd()
  let tagfilename = cwd . "/tags"
  let f = substitute(fullpath, cwd . "/", "", "")
  let f = escape(f, './')
  let cmd = 'LC_ALL=C sed -i "" -e "/' . f . '/d" "' . tagfilename . '"'
  "echo cmd
  let resp = system(cmd)
  "echo resp
endfunction

function! UpdateTags()
  let f = expand("%:p")
  let cwd = getcwd()
  let tagfilename = cwd . "/tags"
  call DelTagOfFile(f)
  let cmd = 'ctags -a -f ' . tagfilename . ' --c++-kinds=+p --fields=+iaS --extra=+q ' . '"' . f . '"'
  "echo cmd
  let resp = system(cmd)
  "echo resp
  "echo "DONE !"
endfunction


function! RegenerateCTags()
  if !exists("g:ctags_regenerate_args")
    let g:ctags_regenerate_args = ''
  endif
  
  let cmd = 'ctags --exclude=log --exclude=tmp --exclude=node_modules '. g:ctags_regenerate_args.' --exclude=.\* --extra=+f -R * '
  echo cmd
  let resp = system(cmd)
  echo resp
  echo "DONE !"
endfunction

map <Leader>rt :call RegenerateCTags()<CR>

" easymotion mapping
let g:EasyMotion_leader_key = '<Leader>]'

" ruby embedded document highlight
function! TextEnableCodeSnip(filetype,start,end,textSnipHl) abort
  let ft=toupper(a:filetype)
  let group='textGroup'.ft
  if exists('b:current_syntax')
    let s:current_syntax=b:current_syntax
    " Remove current syntax definition, as some syntax files (e.g. cpp.vim)
    " do nothing if b:current_syntax is defined.
    unlet b:current_syntax
  endif
  execute 'syntax include @'.group.' syntax/'.a:filetype.'.vim'
  try
    execute 'syntax include @'.group.' after/syntax/'.a:filetype.'.vim'
  catch
  endtry
  if exists('s:current_syntax')
    let b:current_syntax=s:current_syntax
  else
    unlet b:current_syntax
  endif
  execute 'syntax region textSnip'.ft.'
  \ matchgroup='.a:textSnipHl.'
  \ start="'.a:start.'" end="'.a:end.'"
  \ contains=@'.group
endfunction
"mysql embedded document highlight

autocmd FileType,Syntax ruby :call TextEnableCodeSnip('mysql', "<<-SQL", "SQL", 'Comment')
autocmd FileType,Syntax ruby :call TextEnableCodeSnip('javascript', "<<-JS", "JS", 'Comment')
autocmd BufNewFile,BufRead Procfile,Procfile.dev setf yaml

au FileType javascript set dictionary+=$HOME/.janus/vim-node-dict/dict/node.dict

let g:syntastic_html_tidy_ignore_errors = [
    \"trimming empty <i>",
    \"trimming empty <span>",
    \"<input> proprietary attribute \"autocomplete\"",
    \"proprietary attribute \"role\"",
    \"proprietary attribute \"hidden\"",
    \" proprietary attribute \"ng-" ,
    \" proprietary attribute \"ui-"
\]


autocmd Filetype html setlocal ts=2 sts=2 sw=2
autocmd Filetype ruby setlocal ts=2 sts=2 sw=2
autocmd Filetype javascript setlocal ts=2 sts=2 sw=2

let javascript_enable_domhtmlcss=1

" CoffeeScript Tagbar
"let g:tagbar_type_coffee = {
    "\ 'ctagstype' : 'coffee',
    "\ 'kinds'     : [
        "\ 'm:methods',
        "\ 'f:functions',
    "\ ]
"\ }

"let g:ctrlp_buftag_types = {'coffee'     : '--language-force=coffee' ,'javascript'  : '--language-force=neojs'  }
"
let g:ctrlp_root_markers = ['.vimrc']





GitGutterDisable


" SUPPORT VIM PROJECT FILES
" enable per-directory .vimrc files
set exrc            
" disable unsafe commands in local .vimrc files
set secure          
let b:thisdir=expand("%:p:h")
let b:vim=b:thisdir.'/.vimrc'
if (filereadable(b:vim))
  let b:vim=substitute(b:vim,' ','\\ ','g')
  execute "source ".b:vim
endif

let g:jsx_ext_required = 0

" use ag 'the silver searcher' instead of ack 
if executable('ag')
  let g:ackprg = 'ag --vimgrep'
"  set grepprg=ag\ --nogroup\ --nocolor
    
endif

let g:ctrlp_use_caching = 0

if 0 " multilien comment hack

  let g:ctrlp_match_func = { 'match': 'FuzzyMatcher' }
  let g:ctrlp_user_command = "echo 'none'"


  function! FuzzyMatcher(items, str, limit, mmode, ispath, crfile, regex)
    "mmode 'full-line' 'filename-only' 'first-non-tab' 'until-last-tab'
    let type = ctrlp#call('s:CurTypeName')
    let type = type[1]
    let search_cmd = 'ag --smart-case -l -i -G ""'
    let sort_cmd = 'fzf -i -f "'.a:str.'"'

    if (type=='fil')
      if empty(a:str)
        let cmd= search_cmd.' | tail -n '.a:limit
      else
        let cmd = (a:regex) ? search_cmd : search_cmd.' | '.sort_cmd
      endif
      let items = split(system(cmd),"\n")
      if (a:regex)
        let exc = exists('s:crfilerel') ? s:crfilerel : ''
        let items = ctrlp#call('s:MatchIt',items, a:str, a:limit, exc)
      endif
    else
      let exc = exists('s:crfilerel') ? s:crfilerel : ''
      let items = ctrlp#call('s:MatchIt',copy(a:items), a:str, a:limit, '')
    endif
    return items

  endfunction

endif
